#![doc = "Peripheral access API for F1C100S microcontrollers (generated using svd2rust v0.37.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_cfg))]
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[doc = "Clock Control Unit - PLLs, Bus Clocks, Gating and Reset"]
pub type Ccu = crate::Periph<ccu::RegisterBlock, 0x01c2_0000>;
impl core::fmt::Debug for Ccu {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ccu").finish()
    }
}
#[doc = "Clock Control Unit - PLLs, Bus Clocks, Gating and Reset"]
pub mod ccu;
#[doc = "Universal asynchronous receiver/transmitter"]
#[doc(alias = "UART0")]
pub type Uart0 = crate::Periph<uart::RegisterBlock, 0x01c2_5000>;
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart").finish()
    }
}
#[doc = "Universal asynchronous receiver/transmitter"]
#[doc(alias = "UART1")]
pub type Uart1 = crate::Periph<uart::RegisterBlock, 0x01c2_5400>;
impl core::fmt::Debug for Uart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart").finish()
    }
}
#[doc = "Universal asynchronous receiver/transmitter"]
#[doc(alias = "UART2")]
pub type Uart2 = crate::Periph<uart::RegisterBlock, 0x01c2_5800>;
impl core::fmt::Debug for Uart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart").finish()
    }
}
#[doc = "Universal asynchronous receiver/transmitter"]
pub mod uart;
#[doc = "Timer, Watchdog and AVS Counter"]
pub type Timer = crate::Periph<timer::RegisterBlock, 0x01c2_0c00>;
impl core::fmt::Debug for Timer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timer").finish()
    }
}
#[doc = "Timer, Watchdog and AVS Counter"]
pub mod timer;
#[doc = "Port Controller (GPIO)"]
pub type Pio = crate::Periph<pio::RegisterBlock, 0x01c2_0800>;
impl core::fmt::Debug for Pio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio").finish()
    }
}
#[doc = "Port Controller (GPIO)"]
pub mod pio;
#[doc = "Interrupt Controller - Handles up to 64 interrupt sources with 4-level priority, fast forcing, and NMI support"]
pub type Intc = crate::Periph<intc::RegisterBlock, 0x01c2_0400>;
impl core::fmt::Debug for Intc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Intc").finish()
    }
}
#[doc = "Interrupt Controller - Handles up to 64 interrupt sources with 4-level priority, fast forcing, and NMI support"]
pub mod intc;
#[doc = "DMA Controller - 4 Normal DMA (NDMA) channels and 4 Dedicated DMA (DDMA) channels"]
pub type Dma = crate::Periph<dma::RegisterBlock, 0x01c0_2000>;
impl core::fmt::Debug for Dma {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dma").finish()
    }
}
#[doc = "DMA Controller - 4 Normal DMA (NDMA) channels and 4 Dedicated DMA (DDMA) channels"]
pub mod dma;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "CCU"]
    pub ccu: Ccu,
    #[doc = "UART0"]
    pub uart0: Uart0,
    #[doc = "UART1"]
    pub uart1: Uart1,
    #[doc = "UART2"]
    pub uart2: Uart2,
    #[doc = "TIMER"]
    pub timer: Timer,
    #[doc = "PIO"]
    pub pio: Pio,
    #[doc = "INTC"]
    pub intc: Intc,
    #[doc = "DMA"]
    pub dma: Dma,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            ccu: Ccu::steal(),
            uart0: Uart0::steal(),
            uart1: Uart1::steal(),
            uart2: Uart2::steal(),
            timer: Timer::steal(),
            pio: Pio::steal(),
            intc: Intc::steal(),
            dma: Dma::steal(),
        }
    }
}
